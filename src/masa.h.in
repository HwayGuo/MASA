// -*-c++-*-
//
//-----------------------------------------------------------------------bl-
//--------------------------------------------------------------------------
//
// MASA - Manufactured Analytical Solutions Abstraction Library
//
// Copyright (C) 2010,2011 The PECOS Development Team
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the Version 2.1 GNU Lesser General
// Public License as published by the Free Software Foundation.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc. 51 Franklin Street, Fifth Floor,
// Boston, MA  02110-1301  USA
//
//-----------------------------------------------------------------------el-
//
// masa.h: public functions (C/C++) designed to be exposed in MASA
//
// $Id$
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------

#ifndef MASA_H_
#define MASA_H_

//
// Library version/build info
//

/// \cond

#define MASA_MAJOR_VERSION  0
#define MASA_MINOR_VERSION  30
#define MASA_MICRO_VERSION  0

#define MASA_BUILD_USER     "nick"
#define MASA_BUILD_ARCH     "x86_64-unknown-linux-gnu"
#define MASA_BUILD_HOST     "magus"
#define MASA_BUILD_DATE     "2011-02-24 18:47"
#define MASA_BUILD_VERSION  "18049:18051"

#define MASA_LIB_VERSION    "0.30"
#define MASA_LIB_RELEASE    "Development Build"

#define MASA_CXX            "g++"
#define MASA_CXXFLAGS       "-O0 -fno-unsafe-math-optimizations"

#define MASA_FC            "gfortran"
#define MASA_FCFLAGS       "-O0 -fno-unsafe-math-optimizations"

/// \endcond

/** \page apiC C/C++ Library Interface                                        
 *                                                                            
 * This section outlines the available MASA functions for C/C++.  To          
 * use, make sure to \#include <masa.h> within your source code               
 * files. Several simple examples using these functions are provided          
 * in the examples section.  
 *
 * \section init Initialization Routines
 */


// This header file contains the public functions designed to be exposed in MASA
// What follows is the masa.h doxygen documentation headers

/** \file
 * MASA header file containing all public C/C++ API
 * 
 * MASA.h is a header file that contains all the public objects and member functions for the C/C++ interfaces. 
 * To use, be sure to #include <masa.h> in any C or C++ programs calling MASA routines. In addition, all functions are 
 * encapsulated in a MASA namespace, and thus C++ routines require 'using namespace MASA' for access.
 * 
 * Several simple examples for using these functions are provided in the examples section. 
 * Functions which have an integer return value return "0" upon success.
 * 
 */

#ifdef __cplusplus

#include <string>
#include <vector>

namespace MASA
{

  // -------------------------------------
  /// \name Problem Definition Routines 
  // -------------------------------------


  /**
   * masa_init: 
   * 
   * masa_init initalizes a masa manufactured solution class.
   * 
   * This routine takes two arguments, both strings of characters. 
   * The first character string is a handle for the newly initalized 
   * class. ("nick")
   * 
   * The second character string is the unique masa identifier string
   * for a particular masa class. ("euler_1d")
   * 
   */
  template <typename Scalar>
  int masa_init      (std::string handle, std::string unique_solution_string);

  template <typename Scalar>
  int masa_select_mms(std::string handle);

  template <typename Scalar>
  int masa_list_mms  ();

  template <typename Scalar>
  int masa_purge_default_param();

  template <typename Scalar>
  Scalar pass_func    (Scalar (*)(Scalar),Scalar);

  // --------------------------------
  // interact with mms variables
  // --------------------------------

  template <typename Scalar>
  int    masa_init_param();

  template <typename Scalar>
  void   masa_set_param(std::string param_name,Scalar new_value);

  template <typename Scalar>
  Scalar masa_get_param(std::string param_name);

  template <typename Scalar>
  void   masa_set_vec(std::string vector_name,std::vector<Scalar>& new_vector);

  template <typename Scalar>
  int masa_get_vec(std::string vector_name,std::vector<Scalar>& vector);

  // --------------------------------
  // source term(s) -- 1D
  // --------------------------------

  template <typename Scalar>
  Scalar masa_eval_source_t  (Scalar);        // x

  template <typename Scalar>
  Scalar masa_eval_source_t  (Scalar,Scalar); // x,t

  template <typename Scalar>
  Scalar masa_eval_source_u  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_v  (Scalar);        // for SA model

  template <typename Scalar>
  Scalar masa_eval_source_w  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_e  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_e  (Scalar,Scalar (*)(Scalar));

  template <typename Scalar>
  Scalar masa_eval_source_rho(Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_u(Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_v(Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_w(Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_N(Scalar,Scalar (*)(Scalar));

  template <typename Scalar>
  Scalar masa_eval_source_rho_N2(Scalar,Scalar (*)(Scalar));

  template <typename Scalar>
  Scalar masa_eval_source_rho_C(Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_C3(Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_C(Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_C3(Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_boundary(Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_e(Scalar);

  // --------------------------------
  // manufactured analytical solution  -- 1D
  // --------------------------------

  template <typename Scalar>
  Scalar masa_eval_exact_t      (Scalar);        // x

  template <typename Scalar>
  Scalar masa_eval_exact_t      (Scalar,Scalar); // x,t

  template <typename Scalar>
  Scalar masa_eval_exact_u      (Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_v      (Scalar);        // for SA model

  template <typename Scalar>
  Scalar masa_eval_exact_w      (Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_p      (Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho    (Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho_N  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho_N2  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho_C  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho_C3  (Scalar);

  // --------------------------------
  // source term(s) -- 2D
  // --------------------------------

  template <typename Scalar>
  Scalar masa_eval_source_t  (Scalar,Scalar,Scalar); //x,y,t

  template <typename Scalar>
  Scalar masa_eval_source_u  (Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_v  (Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_w  (Scalar,Scalar); // for axisymmetric

  template <typename Scalar>
  Scalar masa_eval_source_e  (Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho(Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_u(Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_v(Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_w(Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_e(Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_nu   (Scalar,Scalar);

  // --------------------------------
  // manufactured analytical solution  -- 2D
  // --------------------------------

  template <typename Scalar>
  Scalar masa_eval_exact_t      (Scalar,Scalar,Scalar); //x,y,t

  template <typename Scalar>
  Scalar masa_eval_exact_u      (Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_v      (Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_w      (Scalar,Scalar); // for axisymmetric

  template <typename Scalar>
  Scalar masa_eval_exact_p      (Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho    (Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_nu   (Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho_C  (Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho_C3  (Scalar,Scalar);

  // --------------------------------
  // source term(s) -- 3D
  // --------------------------------

  template <typename Scalar>
  Scalar masa_eval_source_t  (Scalar,Scalar,Scalar,Scalar); // x,y,z,t

  template <typename Scalar>
  Scalar masa_eval_source_u  (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_v  (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_w  (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_e  (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho(Scalar,Scalar,Scalar); 

  template <typename Scalar>
  Scalar masa_eval_source_rho_u(Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_v(Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_w(Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_rho_e(Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_source_nu   (Scalar,Scalar,Scalar);

  // --------------------------------
  // manufactured analytical solution  -- 3D
  // --------------------------------

  template <typename Scalar>
  Scalar masa_eval_exact_t      (Scalar,Scalar,Scalar,Scalar); // x,y,z,t

  template <typename Scalar>
  Scalar masa_eval_exact_u      (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_v      (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_w      (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_p      (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho    (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_nu     (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho_C  (Scalar,Scalar,Scalar);

  template <typename Scalar>
  Scalar masa_eval_exact_rho_C3  (Scalar,Scalar,Scalar);


  // --------------------------------
  // gradient of analytical solutions
  // --------------------------------

  template <typename Scalar>
  Scalar masa_eval_grad_u  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_grad_u  (Scalar,Scalar,int);

  template <typename Scalar>
  Scalar masa_eval_grad_u  (Scalar,Scalar,Scalar,int);

  template <typename Scalar>
  Scalar masa_eval_grad_v  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_grad_v  (Scalar,Scalar,int);

  template <typename Scalar>
  Scalar masa_eval_grad_v  (Scalar,Scalar,Scalar,int);


  template <typename Scalar>
  Scalar masa_eval_grad_w  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_grad_w  (Scalar,Scalar,int);

  template <typename Scalar>
  Scalar masa_eval_grad_w  (Scalar,Scalar,Scalar,int);


  template <typename Scalar>
  Scalar masa_eval_grad_p  (Scalar);

  template <typename Scalar>
  Scalar masa_eval_grad_p  (Scalar,Scalar,int);

  template <typename Scalar>
  Scalar masa_eval_grad_p  (Scalar,Scalar,Scalar,int);


  template <typename Scalar>
  Scalar masa_eval_grad_rho(Scalar);

  template <typename Scalar>
  Scalar masa_eval_grad_rho(Scalar,Scalar,int);

  template <typename Scalar>
  Scalar masa_eval_grad_rho(Scalar,Scalar,Scalar,int);

  // --------------------------------
  // internal masa functions user might want to call
  // --------------------------------
  void masa_exit(int);                             // calls exit() but with exception handling
  int masa_map (std::string*);
  int masa_map2(std::string, std::string);

  template <typename Scalar>
  int masa_test_poly();

  // --------------------------------
  /// \name Utility functions
  // --------------------------------

  template <typename Scalar>
  int masa_getid(void**,std::string);

  template <typename Scalar>
  int masa_printid();

  template <typename Scalar>
  int masa_display_param();

  template <typename Scalar>
  int masa_display_vec();

  template <typename Scalar>
  int masa_get_name(std::string*);

  template <typename Scalar>
  int masa_get_dimension(int*);

  template <typename Scalar>
  int masa_sanity_check();

  // 
  // Versioning routines
  // --------------------
  int masa_version_stdout();
  int masa_get_numeric_version();

  // --------------------
  // MASAshell
  // --------------------

  void masa_shell_choose_solution();
  void masa_shell_print_avail();
  void masa_shell_choose_solution();
  void masa_shell_print_avail();

  
} //end MASA namespace

#endif // __cplusplus
#endif // MASA_H_


//--------------------------------------------------------------------------
// 
//
// masa.h: contains the public C-interface functions in MASA
//
//
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {
#endif
  
  // --------------------------------
  /// \name Problem Definition Routines
  // --------------------------------

  /**
   * Masa_init initalizes a masa manufactured solution class.
   * 
   * This routine takes two arguments, both strings of characters. 
   * The first character string is a handle for the newly initalized 
   * class. (e.g. "nick's mms")
   * 
   * The second character string is the unique masa identifier string
   * for a particular masa class. (e.g. "euler_1d"). See the tutorial for 
   * more information on all available solution strings.
   * 
   * The routine returns an integer 0 for success. It will throw an 
   * exception and return 1 if no manufactured solutions of the 2nd
   * argument exist. 
   *
   */
  extern int masa_init      (const char* handle, const char* unique_solution_name);

  /**
   * This function sets all masa parameters to uninitalized
   */
  extern int masa_purge_default_param();

  /**
   * masa_select_mms selects an already initalized 
   * manufactured solution class.
   *
   * Thus, if the user had created two manufactured classes (say, nick and bob)
   * using masa_init, he could switch between them by passing the 
   * handle to this routine. 
   * 
   * ex. masa_select_mms("nick")
   * 
   * Subroutine returns integer 0 for success.
   */
  extern int masa_select_mms(const char* handle);

  /**
   * This will display (to stdout) the number of 
   * user initalized solutions. 
   * 
   * In addition, it will then display each solutions unique handle and 
   * full manufactured class name
   *
   * Subroutine returns integer 0 for success.
   */
  extern int masa_list_mms  ();

  // --------------------------------
  // interact with mms variables
  // --------------------------------

  /**
   * Subroutine that will initalize
   * all the registered variables to selected defaults
   * for the currently selected manufactured solution class. 
   *
   * Returns integer 0 for success. A return value of n indicates 
   * n failures within init_param, generally from calling set_var()
   * with incorrect arguments.
   *
   */
  extern int    masa_init_param();

  /**
   * Subroutine that will set 
   * a particular registered variables inside 
   * the currently selected manufactured solution class. 
   *
   * This routine takes two arguments: a character string for
   * the particular variable to be set, and a double precision
   * number to use as the new value of the variable.
   * 
   * This routine can be called multiple times, with subsequent
   * calls overwriting the previously held variable value. 
   */
  extern void   masa_set_param(const char* param_name,double new_value);

  /**
   * Will return
   * a particular registered variables inside 
   * the currently selected manufactured solution class. 
   *
   * This routine takes one argument: a character string for
   * the particular variable value to be returned.
   * 
   * Subroutine returns a double of the currently held value
   * of the specified variable. 
   */
  extern double masa_get_param(const char* param_name);

  /**
   * Subroutine that will set 
   * a particular registered vector inside 
   * the currently selected manufactured solution class. 
   *
   * This routine takes three arguments: a character string for
   * the particular variable to be set, an integer
   * specifying the length of the array, and a double precision
   * pointer to an array.
   * 
   * This routine can be called multiple times, with subsequent
   * calls overwriting the previously held array. 
   */
  extern void   masa_set_array(const char* vector_name,int *n,double new_array[]);

  /**
   * Will return
   * a particular registered variables inside 
   * the currently selected manufactured solution class. 
   *
   * This routine takes three arguments: a character string for
   * the particular variable value to be returned, an integer 
   * passed-by-reference specifying the length of the array, 
   * and a pointer returning the address of the array
   * 
   */
  extern int masa_get_array(const char* param_name, int *n, double* array);

  //  --------------------------------
  /// \name 1D Source Terms
  //  --------------------------------

  /**
   * Subroutine that will return the value of the source 
   * term for the temperature of the currently selected
   * one dimensional masa function 
   */
  extern double masa_eval_1d_source_t  (double x);

  /**
   * Subroutine that will return
   * the value of the source term for the u component of velocity
   * of the currently selected
   * one dimensional masa function 
   *
   * Subroutine returns a double of the currently held value
   * of the specified variable. 
   */
  extern double masa_eval_1d_source_u  (double x);

  /**
   * Subroutine that will return
   * the value of the source term for the energy
   * of the currently selected
   * one dimensional masa function 
   */
  extern double masa_eval_1d_source_e  (double x);

  /**
   * Subroutine that will return
   * the value of the source term for the density
   * of the currently selected
   * one dimensional masa function 
   *
   * Subroutine returns a double of the currently held value
   * of the specified variable. 
   */
  extern double masa_eval_1d_source_rho(double x);

  /**
   * Subroutine that will return
   * the value of the source term for the density*u-component of
   * velocity of the currently selected
   * one dimensional masa function 
   * Subroutine returns a double of the currently held value
   * of the specified variable. 
   */
  extern double masa_eval_1d_source_rho_u (double x);


  /**
   * Subroutine that will return
   * the value of the source term for the density*energy of
   * velocity of the currently selected
   * one dimensional masa function 
   * Subroutine returns a double of the currently held value
   * of the specified variable. 
   */
  extern double masa_eval_1d_source_rho_e (double x);

   /**
   * Subroutine that will return
   * the value of the source term for 
   * the concentration of Nitrogen
   * in the currently selected one dimensional masa function.
   * Note that the 2nd argument is a function pointer, specifying 
   * the address of a function that provides the reaction rate constant
   * as a function of temperature.
   */
  extern double masa_eval_1d_source_rho_N (double x,double (*)(double));

  /**
   * Subroutine that will return
   * the value of the source term for 
   * the concentration of Nitrogen-two
   * in the currently selected one dimensional masa function.
   * Here, the 2nd argument is a function pointer, specifying 
   * the address of a function that provides the reaction rate constant
   * as a function of temperature.
   */
  extern double masa_eval_1d_source_rho_N2(double x,double (*)(double));

  // --------------------------------
  /// \name 1D Manufactured Analytical Solution Terms
  // --------------------------------

  /**
   * Subroutine that will return
   * the value of the analytical term for the temperature
   * of the currently selected one dimensional masa function.
   *
   * Subroutine returns a double of the currently held value
   * of the specified variable. 
   */
  extern double masa_eval_1d_exact_t      (double x);

  /**
   * Subroutine that will return
   * the value of the analytical term for the u component of velocity
   * of the currently selected one dimensional masa function.
   * Subroutine returns a double of the currently held value
   * of the specified variable. 
   */
  extern double masa_eval_1d_exact_u      (double x);

  /**
   * This subroutine will return
   * the value of the analytical term for the pressure
   * of the currently selected one dimensional masa function.
   * Subroutine returns a double of the currently held value
   * of the specified variable. 
   */
  extern double masa_eval_1d_exact_p      (double x);

  /**
   * Subroutine that will return
   * the value of the manufactured analytical term for the density
   * of the currently selected one dimensional masa function.
   */
  extern double masa_eval_1d_exact_rho      (double x);

  /**
   * Subroutine that will return
   * the value of the manufactured analytical term for 
   * concentration of Nitrogen
   * in the currently selected one dimensional masa function.
   */
  extern double masa_eval_1d_exact_rho_N    (double x);

  /**
   * Subroutine that will return
   * the value of the manufactured analytical term for 
   * the concentration of Nitrogen-two
   * in the currently selected one dimensional masa function.
   */
  extern double masa_eval_1d_exact_rho_N2   (double x);

  // --------------------------------
  /// \name 2D Source Terms
  // --------------------------------

  /**
   * Subroutine that will return
   * the value of the source term for the temperature of the currently selected
   * two dimensional masa function.
   */
  extern double masa_eval_2d_source_t  (double x,double y);

  /**
   * Subroutine that will return
   * the value of the source term for the u component of velocity
   * for the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_source_u  (double x,double y);

  /**
   * Subroutine that will return
   * the value of the source term for the v component of velocity
   * for the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_source_v  (double x,double y);

  /**
   * Subroutine that will return
   * the value of the source term for the energy
   * of the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_source_e  (double x,double y);

  /**
   * Subroutine that will return
   * the value of the source term for the density
   * of the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_source_rho(double x,double y);

  /**
   * Subroutine that will return
   * the value of the source term for the density*u-component
   * of velocity for the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_source_rho_u(double x,double y);

  /**
   * Returns the value of the source term for the density*v-component
   * of velocity for the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_source_rho_v(double x,double y);

  /**
   * Returns the value of the source term for the density*w-component
   * of velocity for the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_source_rho_w(double x,double y);

  /**
   * Returns the value of the source term for the density*energy
   * for the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_source_rho_e(double x,double y);

  // --------------------------------
  /// \name 2D Manufactured Analytical Solution Terms
  // --------------------------------

  /**
   * subroutine that returns the value of the analytical term 
   * for the temperature of the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_exact_t      (double x,double y);

  /**
   * Subroutine that will return
   * the value of the analytical term for the u component of velocity
   * of the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_exact_u      (double x,double y);

  /**
   * Subroutine that will return
   * the value of the analytical term for the v component of velocity
   * of the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_exact_v      (double x,double y);

  /**
   * Subroutine that will return
   * the value of the analytical term for the pressure
   * of the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_exact_p      (double x,double y);

  /**
   * A subroutine that will return
   * the value of the analytical term for the density
   * of the currently selected two dimensional masa function.
   */
  extern double masa_eval_2d_exact_rho    (double x,double y);

  // --------------------------------
  /// \name 3D Source Terms
  // --------------------------------

  /**
   * A subroutine that will return
   * the value of the source term for the temperature of the currently selected
   * three dimensional masa function 
   */
  extern double masa_eval_3d_source_t  (double x,double y,double z);

  /**
   * A subroutine that will return
   * the value of the source term for the u component of velocity
   * for the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_source_u  (double x,double y,double z);

  /**
   * A subroutine that will return
   * the value of the source term for the v component of velocity
   * for the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_source_v  (double x,double y,double z);

  /**
   * A subroutine that will return
   * the value of the source term for the w component of velocity
   * for the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_source_w  (double x,double y,double z);

  /**
   * A subroutine that will return
   * the value of the source term for the energy
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_source_e  (double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the source term for the density
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_source_rho(double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the source term for the density*u-component of velocity
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_source_rho_u(double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the source term for the density*v-component of velocity
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_source_rho_v(double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the source term for the density*w-component of velocity
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_source_rho_w(double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the source term for the density*energy
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_source_rho_e(double x,double y,double z);

  // --------------------------------
  /// \name 3D Manufactured Analytical Solution Terms
  // --------------------------------

  /**
   * This subroutine returns 
   * the value of the analytical term for the temperature of the 
   * currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_exact_t      (double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the analytical term for the u component of velocity
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_exact_u      (double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the analytical term for the v component of velocity
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_exact_v      (double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the analytical term for the w component of velocity
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_exact_w      (double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the analytical term for the pressure
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_exact_p      (double x,double y,double z);

  /**
   * This subroutine returns 
   * the value of the analytical term for the density
   * of the currently selected three dimensional masa function.
   */
  extern double masa_eval_3d_exact_rho    (double x,double y,double z);

  // --------------------------------
  /// \name Gradients of Analytical Solutions
  // --------------------------------

  //
  // u-component
  //

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the u-component of velocity.
   * It should be called for solutions with a single dimension.
   */
  extern double masa_eval_1d_grad_u(double x);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the u-component of velocity.
   * It should be called for solutions with two dimensions.
   */
  extern double masa_eval_2d_grad_u(double x,double y,int direction);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the u-component of velocity.
   * It should be called for solutions with three dimensions.
   */
  extern double masa_eval_3d_grad_u(double x,double y,double z,int direction);

  //
  // v-component
  //

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the v-component of velocity.
   * It should be called for solutions with a single dimension.
   */
  extern double masa_eval_1d_grad_v(double x);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the v-component of velocity.
   * It should be called for solutions with two dimensions.
   */
  extern double masa_eval_2d_grad_v(double x,double y,int direction);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the v-component of velocity.
   * It should be called for solutions with three dimensions.
   */
  extern double masa_eval_3d_grad_v(double x,double y,double z,int direction);

  //
  // w-component
  //

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the w-component of velocity.
   * It should be called for solutions with a single dimension.
   */
  extern double masa_eval_1d_grad_w(double x);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the w-component of velocity.
   * It should be called for solutions with two dimensions.
   */
  extern double masa_eval_2d_grad_w(double x,double y,int direction);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the w-component of velocity.
   * It should be called for solutions with three dimensions.
   */
  extern double masa_eval_3d_grad_w(double x,double y,double z,int direction);


  //
  // pressure
  //

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the pressure.
   * It should be called for solutions with a single dimension.
   */
  extern double masa_eval_1d_grad_p(double x);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the pressure.
   * It should be called for solutions with two dimensions.
   */
  extern double masa_eval_2d_grad_p(double x,double y,int direction);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the pressure.
   * It should be called for solutions with three dimensions.
   */
  extern double masa_eval_3d_grad_p(double x,double y,double z,int direction);

  //
  // density (rho)
  //

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the density (rho).
   * It should be called for solutions with a single dimension.
   */
  extern double masa_eval_1d_grad_rho(double x);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the density (rho).
   * It should be called for solutions with two dimensions.
   */
  extern double masa_eval_2d_grad_rho(double x,double y,int direction);

  /**
   * This subroutine returns the gradient of the analytical solution
   * for the density (rho).
   * It should be called for solutions with three dimensions.
   */
  extern double masa_eval_3d_grad_rho(double x,double y,double z,int direction);


  // --------------------------------
  /// \name Utility functions
  // --------------------------------
  
  /**
   * Subroutine will return a string with the current manufactured solution
   * name.
   */       
  extern int masa_get_name(const char* name);

  /**
   * Subroutine takes an integer pointer, which is returned as the dimension 
   * of the currently initialized solution.
   */       
  extern int masa_get_dimension(int* dimension);

  /**
   * Subroutine will output the currently selected manufactured
   * solution class' parameter names and values to standard output
   */       
  extern int masa_display_param();

  /**
   * Subroutine will output the currently selected manufactured
   * solution class' vector names and lengths to standard output
   */       
  extern int masa_display_array();

  /**
   * Subroutine that will check that all parameters for
   * the currently selected masa manufactured class have been
   * initalized to some value.
   * 
   * Subroutine returns an integer 0 on success.
   */
  extern int masa_sanity_check();

#ifdef __cplusplus
}
#endif

