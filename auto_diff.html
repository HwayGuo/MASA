<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>MASA-0.44.0: Creating Manufactured Solutions with Automatic Differentiation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MASA-0.44.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Creating Manufactured Solutions with Automatic Differentiation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Although most of the manufactured solutions currently in MASA were created via symbolic manipulation using computational algebra systems, the difficulty in constructing such solutions may be prohibitive for some users with particularly complicated PDEs.</p>
<p>To enable easier development of code for evaluating forcing terms, MASA provides a simple set of classes for automatic differentiation of manufactured solutions.</p>
<p>The primary class required to perform automatic differentiation with MASA is:</p>
<div class="fragment"><div class="line">DualNumber&lt;ValueType, DerivativeType&gt;</div>
</div><!-- fragment --><p>Each object of this class stores one conceptually-scalar value of type <code>ValueType</code> accessible with the member function <code>value()</code>, as well as the first derivative(s) of that value of type <code>DerivativeType</code> accessible with the member function <code>derivatives()</code>. Arithmetic operators for the class are overloaded, and the std:: operators from &lt;cmath&gt; are defined, in order to enable these objects to be used in any type-independent code which expects ordinary mathematical scalars. When these objects are transformed by mathematical operations and functions, the functions are applied directly to the <code>value()</code> and the corresponding differentiation rules are applied to the <code>derivatives()</code>.</p>
<p>For operations on collections of numbers, as occur in multidimensional problems, the corresponding MASA data type is:</p>
<div class="fragment"><div class="line">NumberArray&lt;Dimension, ValueType&gt;</div>
</div><!-- fragment --><p>For example, with Dimension=2 and ValueType=double, the type <code>NumberArray&lt;2,double&gt;</code> represents a 2-D algebraic vector.</p>
<p>To make these classes useful for more than simple problems, they must be composed into more elaborate types; they are designed to enable this composition both with each other and recursively with themselves. For example, a double-precision scalar which is twice-differentiable with respect to one variable can be created by using the recursive type</p>
<div class="fragment"><div class="line">DualNumber&lt;DualNumber&lt;double,double&gt;, DualNumber&lt;double,double&gt; &gt;</div>
</div><!-- fragment --><p>or a 3-D algebraic double-precision matrix can be constructed with the recursive type</p>
<div class="fragment"><div class="line">NumberArray&lt;3, NumberArray&lt;3, double&gt; &gt;</div>
</div><!-- fragment --><p>For differentiable functions of multiple variables, combinations of <code>DualNumber</code> and <code>NumberArray</code> are required, wherein the NumberArray based types are needed to represent gradient vectors and Hessian matrices given by derivatives of the scalar-valued DualNumber. For instance, a double-precision scalar-valued function of two coordinates which is once-differentiable can be defined with the type</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> DualNumber&lt;double, NumberArray&lt;2, double&gt; &gt; ADOne;</div>
</div><!-- fragment --><p>This sort of operation can be performed recursively to give a twice differentiable function:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> DualNumber&lt;ADOne, NumberArray&lt;2, ADOne&gt; &gt; ADTwo;</div>
</div><!-- fragment --><p>And any differentiable scalar-valued function can be extended to a vector-valued function by being placed in a <code>NumberArray:</code> </p>
<div class="fragment"><div class="line">NumberArray&lt;2, ADTwo&gt; U;</div>
</div><!-- fragment --><p>To initialize an automatically differentiable function variable properly, one must first initialize the independent variables with respect to which later differentiation will occur. Each independent variable should have a derivative which is a unit vector in the direction corresponding to that variable. In the above examples, evaluation at a point (x,y) = (0.3,0.4) can begin with</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unitvec1[] = {1, 0};</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> unitvec2[] = {0, 1};</div>
<div class="line">ADTwo x(0.3, unitvec1);</div>
<div class="line">ADTwo y(0.4, unitvec2);</div>
</div><!-- fragment --><p>Later reassignment of independent variables also requires manual instantiation of derivatives. In the following code,</p>
<div class="fragment"><div class="line">x = ADTwo(0.4, unitvec1);</div>
<div class="line">x = 0.5;</div>
</div><!-- fragment --><p>the first statement properly reassigns the value of <code>x</code> to 0.4 while leaving its status as an independent variable unchanged. The second statement makes <code>x</code> a constant with value 0.5, and if this <code>x</code> is used in further calculations, differentiation with respect to x will silently give incorrect results!</p>
<p>Presuming that independent variables have been set correctly, calculations of dependent variables are straightforward, e.g.:</p>
<div class="fragment"><div class="line">ADTwo f = std::pow(1.1, x);</div>
<div class="line">U[0] = 3 * f * std::sin(x) + std::cos(f);</div>
</div><!-- fragment --><p>Intermediate variables of the appropriate types can be created, and upconversion of non-AD constants is automatic. Inadvertent downconversions such as:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> f = std::pow(1.1, x);</div>
</div><!-- fragment --><p>are flagged as errors at compile-time, to prevent users from accidentally making type errors in intermediate calculations. Intentional downconversions can be obtained with the <code>raw_value()</code> function,</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> f = raw_value(std::pow(1.1, x));</div>
</div><!-- fragment --><p>which is useful when differentiable calculations are finished and output values must be provided to other C++ functions which expect raw scalars.</p>
<p>Once differentiable manufacutured solution variables have been calculated, the evaluation of a manufactured forcing function simply requires the differential equation itself to be expressed in C++. Some differential operators are naturally expressed in the designs described above; e.g. a gradient of any <code>DualNumber</code> may be taken with the <code>derivatives()</code> method. Other common mathematical terms are enabled via separate functions applying to class compositions; e.g. a divergence of a vector or tensor expressed as a <code>NumberArray</code> with underlying <code>DualNumber</code> contents can be taken with the <code>divergence()</code> function, or an identity tensor can be obtained with the <code>identity()</code> function.</p>
<p>As an example of a manufactured forcing function calculation with these tools, consider the Navier-Stokes momentum equation:</p>
<div class="fragment"><div class="line">NumberArray&lt;NDIM, double&gt; Q_rho_u =</div>
<div class="line">  raw_value(divergence(RHO*U.outerproduct(U) - Tau) +</div>
<div class="line">  P.derivatives());</div>
</div><!-- fragment --><p>Here we require a vector output, but the output will not have further derivatives taken, so a plain double is used within a <code>NumberArray</code>, and raw_value() is used to initialize that away from an automatically differentiated calculation. An integer compile-time constant or template argument <code>NDIM</code> is used here to write dimension-independent code. The <code>outerproduct()</code> method takes its vector object <code>U</code> and constructs a tensor product with its argument (also <code>U</code> here). The <code>operator*</code> then automatically performs scalar-times-tensor multiplication. The <code>Tau</code> variable here was declared to be a tensor type in an intermediate calculation.</p>
<p>Some aspects of these classes may still be under development. In particular, the identification of the <code>derivatives()</code> method with a spatial gradient presumes a steady-state PDE with no non-spatial independent variables; other methods may be introduced in the future to provide more natural syntax for transient and more complicated PDEs. </p>
</div></div><!-- contents -->
<hr size="1"/><address style="text-align: right;"><small>
Generated on Tue Apr 21 2015 10:22:49 for MASA-0.44.0
by&nbsp;<a href="http://www.doxygen.org/index.html">
<em>doxygen</em></a>
1.8.5</small></address>
</body>
</html>
