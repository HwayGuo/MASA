These are notes I took for internal PECOS use only: this will not be included in the distribution.

Feel free to add anything you think might be useful.

-NM

-----------------------------------------------------------------------------------------------------------

(08:02:24 PM) roystgnr: MASA::axi_cns with two different argument signatures
(08:03:14 PM) nick: whats weird is thats the contructor
(08:13:31 PM) roystgnr: Weird.  
(08:13:34 PM) roystgnr: roystgnr@roystgnr-laptop:~/pecos/mms/MASA/trunk$ nm --demangle src/.libs/libmasa.so | grep axi_cns
000000000008a284 t global constructors keyed to axi_cns.cpp
0000000000084ac8 T MASA::axi_cns::eval_q_rho(double, double)
000000000008a16e T MASA::axi_cns::eval_an_rho(double, double)
00000000000852be T MASA::axi_cns::eval_q_e(double, double)
00000000000826a8 T MASA::axi_cns::eval_q_u(double, double)
0000000000083992 T MASA::axi_cns::eval_q_w(double, double)
0000000000081a3c T MASA::axi_cns::init_var()
000000000008a0a0 T MASA::axi_cns::eval_an_p(double, double)
0000000000089f0e T MASA::axi_cns::eval_an_u(double, double)
0000000000089fd2 T MASA::axi_cns::eval_an_w(double, double)
0000000000080cee T MASA::axi_cns::axi_cns()
000000000007ffa0 T MASA::axi_cns::axi_cns()
000000000008a2dc W MASA::axi_cns::~axi_cns()
000000000008a29a W MASA::axi_cns::~axi_cns()
00000000002a1b10 V typeinfo for MASA::axi_cns
00000000000902e0 V typeinfo name for MASA::axi_cns
00000000002a19a0 V vtable for MASA::axi_cns
(08:13:46 PM) roystgnr: The symbol table has two constructors and two destructors in it.
(08:14:26 PM) roystgnr: There should be a default destructor, but I'm not sure why there'd be two.
(08:14:46 PM) roystgnr: You've defined a void constructor... maybe the other is the default copy constructor?
(08:14:46 PM) csim: yup it's quite weird
(08:17:45 PM) roystgnr: Yeah, I must not understand C++ well enough.  Looking at the FIN-S lib, there's three destructors Properties::Thermodynamic::MixtureThermodynamics::~MixtureThermodynamics() defined
(08:19:13 PM) roystgnr: You can have any number of different constructors depending on arguments, and some of them get generated by the compiler by default, but I thought there was always one and only one destructor per class.
(08:41:55 PM) nick: roy thats still very helpful, thanks
(08:42:32 PM) nick: also didnt know about nm --demangle
(08:54:36 PM) roystgnr: I discovered it by accident just now while looking for information on demangling.  Didn't find enough information at first.
(08:54:40 PM) roystgnr: But check tthis out:
(08:54:45 PM) roystgnr: http://www.codesourcery.com/public/cxx-abi/abi.html
(08:54:58 PM) roystgnr: specifically:
(08:55:00 PM) roystgnr:   <ctor-dtor-name> ::= C1	# complete object constructor		   ::= C2	# base object constructor      ::= C3 # complete object allocating constructor      ::= D0 # deleting destructor      ::= D1 # complete object destructor      ::= D2 # base object destructor 
(08:55:08 PM) roystgnr: damn, that formatting messed up
(08:55:14 PM) roystgnr: but you can search for it in the original file
(08:55:50 PM) roystgnr: Looks like it's the "base object constructor" that's not being hit, whatever that means.
(08:59:35 PM) roystgnr: http://www.cygwin.com/ml/gdb/2004-07/msg00163.html
(08:59:53 PM) roystgnr: The constructor with "C2" in the linkage name is the base object constructor.  Your program calls this constructor when it creates an object derived from A, such as "new B".  Your program does *not* call the base object constructor for "new A".  The difference between type "C1" and type "C2" has to do with virtual base classes.  In C++, the constructor for the complete object initializes all the virtual bases, and constructors for base classes do not initialize any virtual bases. 
(09:01:37 PM) roystgnr: So basically if you've got virtual base classes, it looks like there's no way for lcov to tell you you've got complete coverage: if C derives from B derives from A, then "new C" will hit the base object constructor of B, but the compiler will have generated a base object constructor for C just in case you want to derive D from it later.
(09:02:06 PM) roystgnr: If anyone has enough time on their hands to add this stuff to our code coverage wiki page I'd appreciate it.  ;-)
(09:02:15 PM) roystgnr: but at the moment it seems like I'm talking to myself...
(10:04:18 PM) roystgnr left the room.
(10:04:58 PM) roystgnr entered the room.
(10:22:31 PM) Paul Bauman entered the room.
(10:24:07 PM) Paul Bauman: I'm came in late to this...
(10:24:59 PM) Paul Bauman: but my abstract base class constructors registered as getting touched when I "newed" the derived object...
(10:25:57 PM) Paul Bauman: or this only a problem with 2 or more derived classes?
(10:26:37 PM) Paul Bauman: i.e. in your example above, B's constructor would get hit, but not A's... is that what you're saying?
(10:29:04 PM) roystgnr: In my example above B's and A's base constructor would get hit, but C's wouldn't.
(10:29:47 PM) Paul Bauman: reading the link now
(10:29:59 PM) Paul Bauman: oh, is this a multiple inheritance thing?
(10:30:15 PM) roystgnr: And can't, because there's nothing derived from C.  If you did derive something, call it D, from C, it would just create a new problem because then D's base constructor wouldn't get hit.
(10:30:22 PM) roystgnr: I think it's an abstract base class thing.
(10:30:55 PM) Paul Bauman: oh!
(10:31:03 PM) Paul Bauman: this is why I'm not getting complete function coverage
(10:31:33 PM) Paul Bauman: I think I get it now
(10:31:50 PM) roystgnr: In nick's MASA problem he's only got the two levels of classes: manufactured_solution is virtual, axi_cns is derived from it... but since nothing is derived from axi_cns, the base constructor of axi_cns never gets called, only the complete constructor does.
(10:32:09 PM) Paul Bauman: right, I see the same thing
(10:32:47 PM) roystgnr: there ought to be a way to tell lcov to lump those together; they're different symbols to the linker but they're generated from the same code by the compiler.